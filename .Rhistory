## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data)
x$setinverse(m)
m
}
cacheSolve(a)
a <- matrix(runif(16),4,4)
cacheSolve(a)
a <- makeCacheMatrix(x = matrix(1:9,nrow=3,ncol=3))
cacheSolve(a)
cacheSolve(m)
a$get()
a$getinverse()
a$setinverse()
a$setinverse(m)
cacheSolve(m)
cacheSolve(a)
a$setinverse(10)
cacheSolve(a)
a <- makeCacheMatrix(x = matrix(runif(16),4,4))
cacheSolve(a)
a$getinverse
a$getinverse()
a$get()
m
a$m
getwd()
setwd("C:/User/jasen/Work/R")
setwd(C:/User/jasen/Work/R)
setwd("C:/User/jasen/Work/R")
setwd("C:\User\jasen\Work\R")
getwd()
devtools::install_github('rstudio/shinyapps')
install.packages('devtools')
devtools::install_github('rstudio/shinyapps')
shinyapps::setAccountInfo(name='jasenmackie', token='A8C6CC5B172D3BFB256953758D046322', secret='SdlkaCM5XYSWYhNCSIYn0hxKMbx9D3iYAKh28DNV')
library(shinyapps)
shinyapps::deployApp('path/to/your/app')
install.packages(c('ggplot2', 'shiny'))
library(shiny)
runApp()
install.packages("shinyapps")
install.packages("shinyapps")
library(shiny)
runApp()
getwd()
setwd("C:/Users/jasen/Work/R/R scripts/demoshinyapp")
shiny::runApp()
dataset
library(shiny)
library(ggplot2)
dataset <- diamonds
fluidPage(
)
head(dataset)
data <- read.csv("test.csv", header = TRUE, stringsAsFactors=F)
setwd("C:/Users/jasen/Work/R/R scripts/Momentum_Chart_app")
data <- read.csv("test.csv", header = TRUE, stringsAsFactors=F)
data_industry <- read.csv("TOP40-INDUSTRY.csv", row.names=1, header = FALSE, stringsAsFactors=F)
rownames(data_industry) <- gsub(rownames(data_industry),pattern = " ", replacement = ".")
View(data)
View(data_industry)
names(dataset)
require(quantmod)
require(PerformanceAnalytics)
require(ggplot2)
require(directlabels)
#Step 1: Get the data
data <- read.csv("test.csv", header = TRUE, stringsAsFactors=F)
data_industry <- read.csv("TOP40-INDUSTRY.csv", row.names=1, header = FALSE, stringsAsFactors=F)
rownames(data_industry) <- gsub(rownames(data_industry),pattern = " ", replacement = ".")
#data_industry <- t(data_industry)
#Step 2: Create your indicator
#calculate number of iterations for loop
numloops <- ncol(data)/3
#create new xts objects
sumMACDarr <- xts()
MACD_short <- xts()
MACD_long <- xts()
#time to loop
for(i in 1:numloops){
s1.dates <- as.Date(data[,i*3-1], format="%d/%m/%Y")
s1 <- xts(data[,i*3], s1.dates)
#Compute Short Period MACD
macd1 <- MACD(s1,12,26,9,maType = "EMA", percent = FALSE)
m_int1 <- (macd1$macd - macd1$signal)/s1
m_int1[is.na(m_int1)] <- 0
m_int1 <- ifelse(m_int1 > 0.02, 0.02, m_int1)
m_int1 <- ifelse(m_int1 < -0.02, -0.02, m_int1)
colnames(m_int1) <- data[1,i*3-2]
MACD_short <- cbind(MACD_short,m_int1)
#MACD_short <- as.data.frame(MACD_short)
#Compute Long Period MACD
macd2 <- MACD(s1,240,520,180,maType = "EMA", percent = FALSE)
m_int2 <- (macd2$macd - macd2$signal)/s1
m_int2[is.na(m_int2)] <- 0
m_int2 <- ifelse(m_int2 > 0.06, 0.06, m_int2)
m_int2 <- ifelse(m_int2 < -0.06, -0.06, m_int2)
colnames(m_int2) <- data[1,i*3-2]
MACD_long <- cbind(MACD_long,m_int2)
#MACD_long <- as.data.frame(MACD_long)
sumMACDarr <- cbind(sumMACDarr,m_int1 + m_int2)
}
chartdf <- t(rbind(MACD_short[nrow(MACD_short),], MACD_long[nrow(MACD_long),]))
View(chartdf)
View(data)
shiny::runApp()
data[1,c(1,4)]
setwd("C:/Users/jasen/Work/R/R scripts")
getwd()
#Version 4
#playing with graphs and shading and legend
t1 <- Sys.time()
# Attach packages. You can install packages via:
# install.packages(c("quantmod","TTR","PerformanceAnalytics"))
library(quantmod)
library(TTR)
library(PerformanceAnalytics)
library(ggplot2)
library(timeSeries)
#Read price data and build xts object
data <- read.csv("simSample.csv", header = TRUE, stringsAsFactors=F)
s1.dates <- as.Date(data[,2], format="%d-%m-%Y")
s1 <- xts(data[,3], s1.dates)
#Calculate ROC
ret <- ROC(s1[,1])
#Chart cum returns
chart.CumReturns(ret)
#Set up for Sample() and Replicate()
n <- 10000 #number of replications
b <- FALSE #Sample with/without Replacement (Boolean)
ret_sample <- replicate(n,sample(as.vector(ret[-1,]), replace=b)) #use ret[-1] so we exclude 1st NA value from ROC calc
ret_cum_sample <- apply(ret_sample, 2, function(x) cumsum(x))
ret_cum_samplexts <- xts(ret_cum_sample, s1.dates[-1]) #use s1.dates[-1] so that length of dates is identical to length of ret_sample
#Build the 5% and 95% quantile datasets
ret_5 <- apply(ret_cum_samplexts, 1, function(x) quantile(x, .05))
ret_5 <- as.xts(ret_5)
ret_95 <- apply(ret_cum_samplexts, 1, function(x) quantile(x, .95))
ret_95 <- as.xts(ret_95)
ret_25 <- apply(ret_cum_samplexts, 1, function(x) quantile(x, .25))
ret_25 <- as.xts(ret_25)
ret_75 <- apply(ret_cum_samplexts, 1, function(x) quantile(x, .75))
ret_75 <- as.xts(ret_75)
charts <- merge(ret_5, ret_95, ret_25, ret_75)
#lets try some shading
h <- ggplot(charts, aes(x = index(charts))) +
geom_ribbon(aes(ymin = ret_25, ymax = ret_75, colour = "50%"), alpha = 0.3, fill = "red3") +
geom_ribbon(aes(ymin = ret_5, ymax = ret_95, colour = "90%"), alpha = 0.3, fill = "cornflowerblue") +
theme(axis.text.x = element_text(angle=0, hjust = 0),
axis.title = element_text(face = 'bold', size = 14),
title = element_text(face = 'bold', size = 16),
legend.position = 'bottom',
legend.title = element_blank(),
legend.text = element_text(size = 12),
legend.key.width = unit(2, 'cm'))
h <- h + geom_line(aes(y = cumsum(ret[-1,])), colour = "black", linetype = 1) +
ylab(label="Cumulative Returns") +
ggtitle("Returns Distribution")
h
t2 <- Sys.time()
difftime(t2,t1)
setwd("C:/Users/jasen/Work/R")
#Version 4
#playing with graphs and shading and legend
t1 <- Sys.time()
# Attach packages. You can install packages via:
# install.packages(c("quantmod","TTR","PerformanceAnalytics"))
library(quantmod)
library(TTR)
library(PerformanceAnalytics)
library(ggplot2)
library(timeSeries)
#Read price data and build xts object
data <- read.csv("simSample.csv", header = TRUE, stringsAsFactors=F)
s1.dates <- as.Date(data[,2], format="%d-%m-%Y")
s1 <- xts(data[,3], s1.dates)
#Calculate ROC
ret <- ROC(s1[,1])
#Chart cum returns
chart.CumReturns(ret)
#Set up for Sample() and Replicate()
n <- 10000 #number of replications
b <- FALSE #Sample with/without Replacement (Boolean)
ret_sample <- replicate(n,sample(as.vector(ret[-1,]), replace=b)) #use ret[-1] so we exclude 1st NA value from ROC calc
ret_cum_sample <- apply(ret_sample, 2, function(x) cumsum(x))
ret_cum_samplexts <- xts(ret_cum_sample, s1.dates[-1]) #use s1.dates[-1] so that length of dates is identical to length of ret_sample
#Build the 5% and 95% quantile datasets
ret_5 <- apply(ret_cum_samplexts, 1, function(x) quantile(x, .05))
ret_5 <- as.xts(ret_5)
ret_95 <- apply(ret_cum_samplexts, 1, function(x) quantile(x, .95))
ret_95 <- as.xts(ret_95)
ret_25 <- apply(ret_cum_samplexts, 1, function(x) quantile(x, .25))
ret_25 <- as.xts(ret_25)
ret_75 <- apply(ret_cum_samplexts, 1, function(x) quantile(x, .75))
ret_75 <- as.xts(ret_75)
charts <- merge(ret_5, ret_95, ret_25, ret_75)
#lets try some shading
h <- ggplot(charts, aes(x = index(charts))) +
geom_ribbon(aes(ymin = ret_25, ymax = ret_75, colour = "50%"), alpha = 0.3, fill = "red3") +
geom_ribbon(aes(ymin = ret_5, ymax = ret_95, colour = "90%"), alpha = 0.3, fill = "cornflowerblue") +
theme(axis.text.x = element_text(angle=0, hjust = 0),
axis.title = element_text(face = 'bold', size = 14),
title = element_text(face = 'bold', size = 16),
legend.position = 'bottom',
legend.title = element_blank(),
legend.text = element_text(size = 12),
legend.key.width = unit(2, 'cm'))
h <- h + geom_line(aes(y = cumsum(ret[-1,])), colour = "black", linetype = 1) +
ylab(label="Cumulative Returns") +
ggtitle("Returns Distribution")
h
t2 <- Sys.time()
difftime(t2,t1)
#Version 4
#playing with graphs and shading and legend
t1 <- Sys.time()
# Attach packages. You can install packages via:
# install.packages(c("quantmod","TTR","PerformanceAnalytics"))
library(quantmod)
library(TTR)
library(PerformanceAnalytics)
library(ggplot2)
library(timeSeries)
#Read price data and build xts object
data <- read.csv("simSample.csv", header = TRUE, stringsAsFactors=F)
s1.dates <- as.Date(data[,2], format="%d-%m-%Y")
s1 <- xts(data[,3], s1.dates)
#Calculate ROC
ret <- ROC(s1[,1])
#Chart cum returns
chart.CumReturns(ret)
#Set up for Sample() and Replicate()
n <- 10000 #number of replications
b <- TRUE #Sample with/without Replacement (Boolean)
ret_sample <- replicate(n,sample(as.vector(ret[-1,]), replace=b)) #use ret[-1] so we exclude 1st NA value from ROC calc
ret_cum_sample <- apply(ret_sample, 2, function(x) cumsum(x))
ret_cum_samplexts <- xts(ret_cum_sample, s1.dates[-1]) #use s1.dates[-1] so that length of dates is identical to length of ret_sample
#Build the 5% and 95% quantile datasets
ret_5 <- apply(ret_cum_samplexts, 1, function(x) quantile(x, .05))
ret_5 <- as.xts(ret_5)
ret_95 <- apply(ret_cum_samplexts, 1, function(x) quantile(x, .95))
ret_95 <- as.xts(ret_95)
ret_25 <- apply(ret_cum_samplexts, 1, function(x) quantile(x, .25))
ret_25 <- as.xts(ret_25)
ret_75 <- apply(ret_cum_samplexts, 1, function(x) quantile(x, .75))
ret_75 <- as.xts(ret_75)
charts <- merge(ret_5, ret_95, ret_25, ret_75)
#lets try some shading
h <- ggplot(charts, aes(x = index(charts))) +
geom_ribbon(aes(ymin = ret_25, ymax = ret_75, colour = "50%"), alpha = 0.3, fill = "red3") +
geom_ribbon(aes(ymin = ret_5, ymax = ret_95, colour = "90%"), alpha = 0.3, fill = "cornflowerblue") +
theme(axis.text.x = element_text(angle=0, hjust = 0),
axis.title = element_text(face = 'bold', size = 14),
title = element_text(face = 'bold', size = 16),
legend.position = 'bottom',
legend.title = element_blank(),
legend.text = element_text(size = 12),
legend.key.width = unit(2, 'cm'))
h <- h + geom_line(aes(y = cumsum(ret[-1,])), colour = "black", linetype = 1) +
ylab(label="Cumulative Returns") +
xlab(label="Time") +
ggtitle("Returns Distribution")
h
t2 <- Sys.time()
difftime(t2,t1)
shiny::runApp('R scripts/Momentum_Chart_app')
shiny::runApp('R scripts/checkboxGroupInput_app')
shiny::runApp('R scripts/checkboxGroupInput_app')
shiny::runApp('R scripts/checkboxGroupInput_app')
shiny::runApp('R scripts/checkboxGroupInput_app')
shiny::runApp('R scripts/checkboxGroupInput_app')
shiny::runApp('R scripts/checkboxGroupInput_app')
shiny::runApp('R scripts/checkboxGroupInput_app')
shiny::runApp('R scripts/checkboxGroupInput_app')
shiny::runApp('R scripts/checkboxGroupInput_app')
shiny::runApp('R scripts/checkboxGroupInput_app')
shiny::runApp('R scripts/checkboxGroupInput_app')
shiny::runApp('R scripts/checkboxGroupInput_app')
shiny::runApp('R scripts/checkboxGroupInput_app')
shiny::runApp('R scripts/checkboxGroupInput_app')
shiny::runApp('R scripts/Momentum_Chart_app')
shiny::runApp('R scripts/Momentum_Chart_app')
shiny::runApp('R scripts/checkboxGroupInput_app')
shiny::runApp('R scripts/checkboxGroupInput_app')
data <- read.csv("test.csv", header = TRUE, stringsAsFactors=F)
data_industry <- read.csv("TOP40-INDUSTRY.csv", row.names=1, header = FALSE, stringsAsFactors=F)
rownames(data_industry) <- gsub(rownames(data_industry),pattern = " ", replacement = ".")
#data_industry <- t(data_industry)
#Step 2: Create your indicator
#calculate number of iterations for loop
numloops <- ncol(data)/3
#create new xts objects
sumMACDarr <- xts()
MACD_short <- xts()
MACD_long <- xts()
#time to loop
for(i in 1:numloops){
s1.dates <- as.Date(data[,i*3-1], format="%d/%m/%Y")
s1 <- xts(data[,i*3], s1.dates)
#Compute Short Period MACD
macd1 <- MACD(s1,12,26,9,maType = "EMA", percent = FALSE)
m_int1 <- (macd1$macd - macd1$signal)/s1
m_int1[is.na(m_int1)] <- 0
#m_int1 <- ifelse(m_int1 > 0.02, 0.02, m_int1)
#m_int1 <- ifelse(m_int1 < -0.02, -0.02, m_int1)
colnames(m_int1) <- data[1,i*3-2]
MACD_short <- cbind(MACD_short,m_int1)
#MACD_short <- as.data.frame(MACD_short)
#Compute Long Period MACD
macd2 <- MACD(s1,240,520,180,maType = "EMA", percent = FALSE)
m_int2 <- (macd2$macd - macd2$signal)/s1
m_int2[is.na(m_int2)] <- 0
#m_int2 <- ifelse(m_int2 > 0.06, 0.06, m_int2)
#m_int2 <- ifelse(m_int2 < -0.06, -0.06, m_int2)
colnames(m_int2) <- data[1,i*3-2]
MACD_long <- cbind(MACD_long,m_int2)
#MACD_long <- as.data.frame(MACD_long)
sumMACDarr <- cbind(sumMACDarr,m_int1 + m_int2)
}
chartdf <- t(rbind(MACD_short[nrow(MACD_short),], MACD_long[nrow(MACD_long),]))
chartdf <- as.data.frame(chartdf)
chartdf <- merge(chartdf, data_industry, by="row.names")
View(chartdf)
dataset <- substr(chartdf[,1],1,3)
head(dataset)
substr(chartdf[,1],1,3)
getwd()
setwd("R scripts/checkboxGroupInput_app")
library(shiny)
#load packages
require(quantmod)
require(PerformanceAnalytics)
require(ggplot2)
require(directlabels)
#Step 1: Get the data
data <- read.csv("test.csv", header = TRUE, stringsAsFactors=F)
data_industry <- read.csv("TOP40-INDUSTRY.csv", row.names=1, header = FALSE, stringsAsFactors=F)
rownames(data_industry) <- gsub(rownames(data_industry),pattern = " ", replacement = ".")
#data_industry <- t(data_industry)
#Step 2: Create your indicator
#calculate number of iterations for loop
numloops <- ncol(data)/3
#create new xts objects
sumMACDarr <- xts()
MACD_short <- xts()
MACD_long <- xts()
#time to loop
for(i in 1:numloops){
s1.dates <- as.Date(data[,i*3-1], format="%d/%m/%Y")
s1 <- xts(data[,i*3], s1.dates)
#Compute Short Period MACD
macd1 <- MACD(s1,12,26,9,maType = "EMA", percent = FALSE)
m_int1 <- (macd1$macd - macd1$signal)/s1
m_int1[is.na(m_int1)] <- 0
#m_int1 <- ifelse(m_int1 > 0.02, 0.02, m_int1)
#m_int1 <- ifelse(m_int1 < -0.02, -0.02, m_int1)
colnames(m_int1) <- data[1,i*3-2]
MACD_short <- cbind(MACD_short,m_int1)
#MACD_short <- as.data.frame(MACD_short)
#Compute Long Period MACD
macd2 <- MACD(s1,240,520,180,maType = "EMA", percent = FALSE)
m_int2 <- (macd2$macd - macd2$signal)/s1
m_int2[is.na(m_int2)] <- 0
#m_int2 <- ifelse(m_int2 > 0.06, 0.06, m_int2)
#m_int2 <- ifelse(m_int2 < -0.06, -0.06, m_int2)
colnames(m_int2) <- data[1,i*3-2]
MACD_long <- cbind(MACD_long,m_int2)
#MACD_long <- as.data.frame(MACD_long)
sumMACDarr <- cbind(sumMACDarr,m_int1 + m_int2)
}
chartdf <- t(rbind(MACD_short[nrow(MACD_short),], MACD_long[nrow(MACD_long),]))
chartdf <- as.data.frame(chartdf)
chartdf <- merge(chartdf, data_industry, by="row.names")
dataset <- substr(chartdf[,1],1,3)
head(dataset)
shiny::runApp()
str(dataset)
shiny::runApp()
shiny::runApp()
names(tickerlist)
tickerlist <- substr(chartdf[,1],1,3)
names(tickerlist)
View(chartdf)
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
tickerlist
index(tickerlist)
?which
which(LETTERS == "R")
which(ll <- c(TRUE, FALSE, TRUE, NA, FALSE, FALSE, TRUE)) #> 1 3 7
which(LETTERS == "S")
which(LETTERS == "E")
?index
shiny::runApp()
shiny::runApp()
input$Stocks
chartdf
shiny::runApp()
shiny::runApp()
chartdf[rownames(cat(input$Stocks, ".SJ.Equity")),3]
chartdf[rownames(cat(substr(chartdf[,1],1,3), ".SJ.Equity")),3]
cat(substr(chartdf[,1],1,3), ".SJ.Equity"))
cat(substr(chartdf[,1],1,3), ".SJ.Equity")
chartdf[,1]
chartdf[rownames(input$Stocks),3]
chartdf[rownames(tickerlist),3]
chartdf[index(rownames(tickerlist)),3]
chartdf[1,3]
a <- c(a,b,c)
a <- c("a","b","c")
a<- a[-2]
a
a <- (1,2,3)
a <- c(1,2,3)
b <- c(2,3)
a %in% b
index(a %in% b)
index(a %in% b == TRUE)
index(b %in% a)
as.numeric(a %in b)
c <- as.numeric(a %in% b)
c
index(as.numeric(a %in b))
c
index(c)
index(c != 0)
index(c[!= 0])
c!=0
c
index(c[c != 0])
index(c)
index(c[c!=0])
a %in% b
index(c[c == TRUE])
index(c(c == TRUE)
)
c
index(c[c == 1])
c
class(c)
c <- as.vector(c)
index(c[c == 1])
class(c)
str(c)
which(b)
which(b == a)
?which()
c
c <- a%in%b
c
which(c)
shiny::runApp()
chartdf[subsetvec,3]
chartdf[c(1,2,3),3]
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
a <- c(1,2,3)
b <- c(3,4)
b %in% a
which(b %in% a)
a <- c(1,2,3,4,5,6,7,8,9)
b <- c(1,2,3,4,5)
which(b %in% a)
a <- c(10,20,30,40,50,60,70,80,90)
b <- c(10,20,30,40,50)
which(b %in% a)
c <- which(b %in% a)
c
a[c]
shiny::runApp()
View(chartdf)
substr(chartdf[,1],1,3)
shiny::runApp()
a <- c(10,20,30,40,50,60,70,80,90)
b <- c(60)
c <- which(b %in% a)
c
which(b %in% a)
b
which(a %in% b)
shiny::runApp()
library(rsconnect)
deployApp()
library(rsconnect)
deployApp()
deployApp()
deployApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
deployApp()
deployApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
